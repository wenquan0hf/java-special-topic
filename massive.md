# 海量数据处理

# 常见的海量数据处理方法

1. 给定 a、b 两个文件，各存放50亿个 url，每个 url 各占64字节，内存限制是 4 G，让你找出 a、b 文件共同的 url？ 
方案1：可以估计每个文件安的大小为 50 G×64=320 G，远远大于内存限制的 4 G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 
s 遍历文件 a，对每个 url 求取 ，然后根据所取得的值将 url 分别存储到1000个小文件（记为 ）中。这样每个小文件的大约为 300 M。 
s 遍历文件 b，采取和 a 相同的方式将 url 分别存储到1000各小文件（记为 ）。这样处理后，所有可能相同的 url 都在对应的小文件（ ）中，不对应的小文件不可能有相同的 url。然后我们只要求出1000对小文件中相同的 url 即可。 
s 求每对小文件中相同的 url 时，可以把其中一个小文件的 url 存储到 hash_set 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的 hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。 
方案2：如果允许有一定的错误率，可以使用 Bloom filter，4 G 内存大概可以表示340亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这340亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。 

2. 有10个文件，每个文件 1 G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求你按照 query 的频度排序。 
方案1： 
s 顺序读取10个文件，按照 hash(query)%10的结果将 query 写入到另外10个文件（记为 ）中。这样新生成的文件每个的大小大约也 1 G（假设 hash 函数是随机的）。 
s 找一台内存在 2 G 左右的机器，依次对 用 hash_map(query, query_count)来统计每个 query 出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query 和对应的 query_cout 输出到文件中。这样得到了10个排好序的文件（记为 ）。 
s 对 这10个文件进行归并排序（内排序与外排序相结合）。 
方案2： 
一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的 query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树 /hash_map 等直接来统计每个 query 出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 
方案3： 
与方案1类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。 

3. 有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是 1 M。返回频数最高的100个词。 
方案1：顺序读文件中，对于每个词 x，取 ，然后按照该值存到5000个小文件（记为 ） 中。这样每个文件大概是 200 k 左右。如果其中的有的文件超过了 1 M 大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过 1 M。对 每个小文件，统计每个文件中出现的词以及相应的频率（可以采用 trie 树 /hash_map 等），并取出出现频率最大的100个词（可以用含100个结点 的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 

4. 海量日志数据，提取出某日访问百度次数最多的那个 IP。 
方案1：首先是这一天，并且是访问百度的日志中的 IP 取出来，逐个写入到一个大文件中。注意到 IP 是32位的，最多有 个 IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的 IP（可以采用 hash_map 进 行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的 IP 中，找出那个频率最大的 IP，即为所求。 

5. 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。 
方案1：采用2-Bitmap（每个数分配 2 bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存 内存，还可以接受。然后扫描这2.5亿个整数，查看 Bitmap 中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看 bitmap，把对应位是01的整数输出即可。 
方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 

6. 海量数据分布在100台电脑中，想个办法高校统计出这批数据的 TOP10。 
方案1： 
s 在每台电脑上求出 TOP10，可以采用包含10个元素的堆完成（TOP10 小，用最大堆，TOP10 大，用最小堆）。比如求 TOP10 大，我们首先取前 10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元 素就是 TOP10 大。 
s 求出每台电脑上的 TOP10 后，然后把这100台电脑上的 TOP10 组合起来，共1000个数据，再利用上面类似的方法求出 TOP10 就可以了。 

7. 怎么在海量数据中找出重复次数最多的一个？ 
方案1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。 

8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。 
方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第6题提到的堆机制完成。 

9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？ 
方案1：这题用 trie 树比较合适，hash_map 也应该能行。 

10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。 
方案1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n*le)（le 表示单词的平准长度）。然后是找出出现最频繁的 前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n*lg10)。所以总的时间复杂度，是 O(n*le)与 O(n*lg10)中较大 的哪一个。 

11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。 
方案1：首先根据用 hash 并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。 

12. 100 w 个数中找出最大的100个数。 
方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100 w*lg100)。 
方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100 w*100)。 
方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个 最小的要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想，插入到序列 L 中。依次循环，知道扫描了所有的元素。复杂度为 O(100 w*100)。 

13. 寻找热门查询： 
搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复 读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个 查询串，要求使用的内存不能超过 1 G。 
(1) 请描述你解决这个问题的思路； 
(2) 请给出主要的处理流程，算法，以及算法的复杂度。 
方案1：采用 trie 树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 

14. 一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 O(N)个数并对它们操作。如何找到 个数中的中数？ 
方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有 个）。我们把0到 的整数划分为 N 个范围段，每个段包含 个整数。比如，第一个段位0到 ，第二段为 到 ，…，第 N 个段为 到 。 然后，扫描每个机器上的 N 个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第 N 个区段的数放到第 N 个机器上。 注意这个过程每个机器上存储的数应该是 O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第 k 个机器，在该机器上累加的数大于或等于 ，而在第 k-1 个机器上的累加数小于 ，并把这个数记为 x。那么我们要找的中位数在第 k 个机器中，排在第 位。然后我们对第 k 个机器的数排序，并找出第 个数，即为所求的中位数。复杂度是 的。 
方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这 N 个机器上的数归并起来得到最终的排序。找到第 n 个便是所求。复杂度是 n(i)的。 

15. 最大间隙问题 
给定 n 个实数 ，求着 n 个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。 
方案1：最先想到的方法就是先对这 n 个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法： 
s 找到 n 个数据中最大和最小数据 max 和 min。 
s 用 n-2 个点等分区间[min, max]，即将[min, max]等分为 n-1 个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶 的上界和桶 i+1 的下届相同，即每个桶的大小相同。每个桶的大小为： 。实际上，这些桶的边界构成了一个等差数列（首项为 min，公差为 ），且认为将 min 放入第一个桶，将 max 放入第 n-1 个桶。 
s 将 n 个数放入 n-1 个桶中：将每个元素 分配到某个桶（编号为 index），其中 ，并求出分到每个桶的最大最小数据。 
s 最大间隙：除最大最小数据 max 和 min 以外的 n-2 个数据放入 n-1 个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙 不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶 i 的上界和桶 j 的下界之间产生 。一遍扫描即可完成。 

16. 将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如： 。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出 。 
(1) 请描述你解决这个问题的思路； 
(2) 给出主要的处理流程，算法，以及算法的复杂度； 
(3) 请描述可能的改进。 
方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ， 首先查看 aaa 和 bbb 是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看 bbb 和 ccc 是否在同一个并查集中，如果不在，那么也把 它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是 O(NlgN)的。改进的话，首先可以 记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。 

17. 最大子序列与最大子矩阵问题 
数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。 
方案1：这个问题可以动态规划的思想解决。设 表示以第 i 个元素 结尾的最大子序列，那么显然 。基于这一点可以很快用代码实现。 
最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。 
方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第 i 列和第 j 列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。